import { FrameRenderConfig, VideoStyle } from '@/types/video';

interface CanvasContext {
  canvas: HTMLCanvasElement;
  ctx: CanvasRenderingContext2D;
}

export class FrameRenderer {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;
  private width: number;
  private height: number;
  private particleSystem: Array<{ x: number; y: number; vx: number; vy: number; size: number; color: string }>;
  private geometricPatterns: Array<{ x: number; y: number; size: number; rotation: number; color: string }>;

  constructor(width: number, height: number) {
    this.canvas = document.createElement('canvas');
    this.canvas.width = width;
    this.canvas.height = height;
    
    const ctx = this.canvas.getContext('2d');
    if (!ctx) {
      throw new Error('Could not get 2D context from canvas');
    }
    this.ctx = ctx;
    
    this.width = width;
    this.height = height;
    
    this.particleSystem = [];
    this.geometricPatterns = [];
    
    // Initialize particle system
    this.initializeParticles();
    // Initialize geometric patterns
    this.initializeGeometricPatterns();
  }

  private initializeParticles(): void {
    this.particleSystem = [];
    for (let i = 0; i < 100; i++) {
      this.particleSystem.push({
        x: Math.random() * this.width,
        y: Math.random() * this.height,
        vx: (Math.random() - 0.5) * 2,
        vy: (Math.random() - 0.5) * 2,
        size: Math.random() * 3 + 1,
        color: `hsl(${Math.random() * 360}, 70%, 50%)`
      });
    }
  }

  private initializeGeometricPatterns(): void {
    this.geometricPatterns = [];
    for (let i = 0; i < 20; i++) {
      this.geometricPatterns.push({
        x: Math.random() * this.width,
        y: Math.random() * this.height,
        size: Math.random() * 50 + 20,
        rotation: Math.random() * Math.PI * 2,
        color: `hsl(${Math.random() * 360}, 70%, 50%)`
      });
    }
  }

  renderFrame(config: FrameRenderConfig): ImageData {
    const { style, frameIndex, audioData } = config;
    
    // Clear canvas
    this.ctx.fillStyle = '#000010';
    this.ctx.fillRect(0, 0, this.width, this.height);

    if (Array.isArray(style)) {
      // Auto-generate mode: blend multiple styles
      this.renderAutoGenerated(config);
    } else {
      // Single style mode
      switch (style) {
        case VideoStyle.PARTICLE_SYSTEM:
          this.renderParticleSystem(audioData);
          break;
        case VideoStyle.GEOMETRIC_PATTERNS:
          this.renderGeometricPatterns(audioData);
          break;
        case VideoStyle.WAVEFORM_ANIMATION:
          this.renderWaveformAnimation(audioData);
          break;
        case VideoStyle.GRADIENT_FLOW:
          this.renderGradientFlow(audioData);
          break;
        case VideoStyle.SPECTRUM_3D:
          this.render3DSpectrum(audioData);
          break;
      }
    }

    return this.ctx.getImageData(0, 0, this.width, this.height);
  }

  private renderParticleSystem(audioData: FrameRenderConfig['audioData']): void {
    const { bass, treble, averageAmplitude } = audioData;
    
    // Update and draw particles
    this.particleSystem.forEach((particle, i) => {
      // Update position based on audio data
      const audioInfluence = bass * 10;
      particle.vx += (Math.random() - 0.5) * audioInfluence;
      particle.vy += (Math.random() - 0.5) * audioInfluence;
      
      // Apply damping
      particle.vx *= 0.98;
      particle.vy *= 0.98;
      
      // Update position
      particle.x += particle.vx;
      particle.y += particle.vy;
      
      // Wrap around edges
      if (particle.x < 0) particle.x = this.width;
      if (particle.x > this.width) particle.x = 0;
      if (particle.y < 0) particle.y = this.height;
      if (particle.y > this.height) particle.y = 0;
      
      // Draw particle
      this.ctx.globalAlpha = 0.8;
      this.ctx.fillStyle = particle.color;
      this.ctx.beginPath();
      this.ctx.arc(particle.x, particle.y, particle.size * (1 + treble * 2), 0, Math.PI * 2);
      this.ctx.fill();
    });
    
    this.ctx.globalAlpha = 1;
  }

  private renderGeometricPatterns(audioData: FrameRenderConfig['audioData']): void {
    const { bass, mid, treble, averageAmplitude } = audioData;
    
    this.ctx.strokeStyle = `hsl(${(bass * 360 + Date.now() / 50) % 360}, 70%, 50%)`;
    this.ctx.lineWidth = 2;
    
    this.geometricPatterns.forEach((pattern, i) => {
      // Update rotation based on audio
      pattern.rotation += bass * 0.1;
      
      this.ctx.save();
      this.ctx.translate(pattern.x, pattern.y);
      this.ctx.rotate(pattern.rotation);
      
      // Draw geometric shape
      const size = pattern.size * (1 + mid * 2);
      this.ctx.strokeRect(-size / 2, -size / 2, size, size);
      
      // Draw inner pattern
      this.ctx.strokeStyle = `hsl(${(treble * 360 + 120) % 360}, 70%, 50%)`;
      this.ctx.beginPath();
      this.ctx.arc(0, 0, size * 0.5 * (1 + averageAmplitude), 0, Math.PI * 2);
      this.ctx.stroke();
      
      this.ctx.restore();
    });
  }

  private renderWaveformAnimation(audioData: FrameRenderConfig['audioData']): void {
    const { timeDomain } = audioData;
    
    this.ctx.lineWidth = 3;
    this.ctx.strokeStyle = `hsl(${(Date.now() / 50) % 360}, 70%, 50%)`;
    
    // Draw waveform
    this.ctx.beginPath();
    const sliceWidth = this.width / timeDomain.length;
    let x = 0;
    
    for (let i = 0; i < timeDomain.length; i++) {
      const v = timeDomain[i] / 128.0;
      const y = v * this.height / 2;
      
      if (i === 0) {
        this.ctx.moveTo(x, y);
      } else {
        this.ctx.lineTo(x, y);
      }
      
      x += sliceWidth;
    }
    
    this.ctx.stroke();
    
    // Add second waveform with offset
    this.ctx.strokeStyle = `hsl(${(Date.now() / 50 + 60) % 360}, 70%, 50%)`;
    this.ctx.beginPath();
    x = 0;
    
    for (let i = 0; i < timeDomain.length; i++) {
      const v = timeDomain[timeDomain.length - 1 - i] / 128.0;
      const y = v * this.height / 2;
      
      if (i === 0) {
        this.ctx.moveTo(x, y);
      } else {
        this.ctx.lineTo(x, y);
      }
      
      x += sliceWidth;
    }
    
    this.ctx.stroke();
  }

  private renderGradientFlow(audioData: FrameRenderConfig['audioData']): void {
    const { bass, mid, treble, averageAmplitude, beatDetected } = audioData;
    
    // Create gradient
    const gradient = this.ctx.createLinearGradient(0, 0, this.width, this.height);
    const hue = (Date.now() / 50) % 360;
    
    gradient.addColorStop(0, `hsl(${hue}, 70%, ${30 + bass * 40}%)`);
    gradient.addColorStop(0.5, `hsl(${(hue + 120) % 360}, 70%, ${30 + mid * 40}%)`);
    gradient.addColorStop(1, `hsl(${(hue + 240) % 360}, 70%, ${30 + treble * 40}%)`);
    
    this.ctx.fillStyle = gradient;
    this.ctx.globalAlpha = 0.3 + averageAmplitude * 0.7;
    
    // Draw flowing shapes
    for (let i = 0; i < 5; i++) {
      const y = (this.height / 5) * i;
      this.ctx.save();
      this.ctx.translate((this.width * i) / 5, y);
      this.ctx.rotate(Math.sin(Date.now() / 1000 + i) * 0.5);
      
      this.ctx.fillRect(-50, -50, 100, 200 * (1 + bass));
      this.ctx.restore();
    }
    
    // Beat accentuation
    if (beatDetected) {
      this.ctx.globalAlpha = 0.8;
      this.ctx.fillRect(0, 0, this.width, this.height);
    }
    
    this.ctx.globalAlpha = 1;
  }

  private render3DSpectrum(audioData: FrameRenderConfig['audioData']): void {
    const { frequency } = audioData;
    
    this.ctx.fillStyle = '#000025';
    this.ctx.fillRect(0, 0, this.width, this.height);
    
    const barWidth = this.width / frequency.length * 2;
    
    for (let i = 0; i < frequency.length; i++) {
      const freq = frequency[i];
      const barHeight = (freq / 255) * this.height;
      
      // 3D effect
      const hue = (360 / frequency.length) * i;
      const depth = barHeight * 0.2;
      
      this.ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
      
      // Front face
      this.ctx.fillRect(i * barWidth, this.height - barHeight, barWidth - 1, barHeight);
      
      // Top face for 3D effect
      this.ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
      this.ctx.fillRect(i * barWidth, this.height - barHeight - depth, barWidth - 1, depth);
      
      // Side face for 3D effect
      this.ctx.fillStyle = `hsl(${hue}, 70%, 40%)`;
      this.ctx.fillRect(i * barWidth + barWidth - 1, this.height - barHeight - depth, depth, barHeight + depth);
    }
  }

  private renderAutoGenerated(config: FrameRenderConfig): void {
    const styles = [VideoStyle.PARTICLE_SYSTEM, VideoStyle.GRADIENT_FLOW, VideoStyle.WAVEFORM_ANIMATION];
    const blendRatio = 0.33;
    
    // Render multiple styles with transparency
    this.ctx.globalAlpha = blendRatio;
    this.renderParticleSystem(config.audioData);
    
    this.ctx.globalAlpha = blendRatio;
    this.renderGradientFlow(config.audioData);
    
    this.ctx.globalAlpha = blendRatio;
    this.renderWaveformAnimation(config.audioData);
    
    this.ctx.globalAlpha = 1;
  }

  getCanvas(): HTMLCanvasElement {
    return this.canvas;
  }

  destroy(): void {
    this.particleSystem = [];
    this.geometricPatterns = [];
  }
}